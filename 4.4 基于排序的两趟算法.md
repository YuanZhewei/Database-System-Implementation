## 基于排序的两趟算法

### 两阶段多路归并排序(Two-Phase, Multiway Merge-Sort TPMMS)

1. 将$R​$中的元组放入$M​$个缓冲区，利用主存排序算法对他们进行排序，并将排序得到的子表放到外存中。

2. 将排好序的子表进行归并。在这个阶段，至多能对$M-1$个有序的子表进行归并，这就限制了$R$的大小

为了使TPMMS正常工作，子表不能超过$M-1$个。假设$R$占用$B$个块，因为每个子表包含$M$个块，于是子表的个数为$\frac{B}{M}$ 因此我们要求$\frac{B}{M} \le  M - 1$，即$B \le M(M-1)$，近似为$B \le M^2$

算法第一趟读入$B$个块，并全部写回外存，第二个阶段再次读入到内存，因此总的磁盘I/O次数为$3B$

###利用排序去重
1. 将$R$中的元组放入$M$个缓冲区，利用主存排序算法对他们进行排序，并将排序得到的子表放到外存中。

2. 将排好序的子表进行归并。 

这个算法的磁盘I/O数和排序一样，也是$3B$，要使算法可行，要求$B \le M^2$，即需要$\sqrt{B(R)}$个内存块
###利用排序分组和聚集

$\gamma_L(R)$的两趟算法与$\delta(R)$和TPPMS非常类似，概括如下

1. 将$R$的元组每次读取$M$块到内存中。用$L$的分组属性作为排序关键字，对每$M$块排序排序。将排好序的每一个子表写入磁盘
2. 为每一个子表使用一个主存缓冲区，将每一个子表的第一个块装入缓冲区中
3. 在缓冲区可以获得的第一个元组中反复查找排序关键字的最小值。这个最小值$v$成为下一分组，我们为他
   1. 准备在这个分组的列表$L$上计算所有的聚集
   2. 检查每个排序关键字为$v$的元组，并且累计所需聚集。
   3. 如果一个缓冲区空了，则用同一子表的一个块替换它。
   4. 当不再有排序关键字为$v$的元组时，输出一个由$L$的分组属性和对应的我们已经为这个组计算出的聚集值构成的元组。

这个算法的磁盘I/O数和排序一样，也是$3B$，要使算法可行，要求$B \le M^2$

###基于排序的并算法

包的并$R\cup_BS$简单复制即可。

考虑集合的并$R\cup_SS$

1. 第一趟时，创建$R$和$S$的排序子表
2. 为$R$和$S$的每个子表使用一个内存缓冲区，用对应子表的第一块初始化各缓冲区
3. 重复地所有缓冲区中查找剩余的第一个元组$t$。将$t$复制到输出，并且从缓冲区删除$t$的所有副本。

磁盘I/O为$3(B(R) + B(S))$，要求为$B(R)+B(S) \le M^2$
###基于排序的交和差算法

算法基本同基于排序的并算法相同。使用如下的算法产生结果，并将输入缓冲里所有$t$的拷贝移除

* 对于集合交$R\cap_SS$，如果$t$在$R$和$S$中都出现就输出$t$
* 对于包交$R\cap_BS$，输出$t$的次数是它在$R$和$S$中出现的最小次数
* 对于集合差$R-_SS$，当且仅当$t$出现在$R$中但不在$S$中时输出$t$
* 对于包差$R-_BS$，输出$t$的次数是$t$在$R$中出现的次数减去$t$在$S$中出现的次数

磁盘I/O为3(B(R) + B(S))，要求为

###基于排序的一个简单的连接算法
已知要连接的关系$R(X, Y)$和$S(Y,Z)$
1. 用$Y$作为排序关键字，是用2PMMS对$R$进行排序
2. 对$S$进行排序
3. 归并排序好的$R$和$S$。仅使用两个缓冲区，一个给$R$的当前块，另一个给$S$的当前块，重复执行以下步骤
   1. 在当前$R$和$S$的块的前端查找连接属性$Y$的最小值$y$
   2. 如果$y$在另一个关系的前部没有出现，那么删除具有排序关键字$y$的元组
   3. 否则，找出两个关系中具有排序关键字$y$的所有元组，直到确定的每一个关系都不再有$y$的副本。最多可以使用$M$个缓冲区来缓存
   4. 输出连接$R$和$S$中具有共同$Y$值$y$的元组所能形成的所有元祖
###简单的排序连接的分析

对$R$和$S$进行排序并写到磁盘需要$4(B(R)+B(S))$次I/O，归并需要$B(R)+B(S)$次I/O

* 简单排序连接使用$5(B(R)+B(S))$次I/O
* 要求$B(R) \le M^2 and B(S) \le M^2$
* 要求具有公共属性值的所有元组能装入$M$个缓冲区中

###一种更有效的基于排序的连接

如果连接属性上具有公共的值的元组太多，那么可以将排序的第二阶段和连接合并，对于每个块可以节约两次磁盘I/O，我们称这个算法为排序-连接算法

还有一些其他的名字如“归并-连接”和“排序-归并-连接”也指这个算法

1. 用$Y$做排序关键字，为$R$和$S$创建大小为$M$的排序的子表

2. 将每一个子表的第一块放入缓冲区

3. 重复地在所有子表的第一个可得到的元组中查找最小的$Y$值$y$。识别两个关系中具有$Y$值$y$的所有元组，如果子表个数小于$M$，可能使用$M$个缓冲区的一部分来容纳这些元组。输出$R$和$S$中具有此公共$Y$值的所有连接

要求两个关系的总的子表数最多是$M$，因此，$B(R) +B(S) \le M^2$

###基于排序的算法的总结

|   操作符    | 大致需要的$M$ | 磁盘I/O |
| :---------: | :---------: | :-----: |
| $\tau,\gamma, \delta$ | $\sqrt{B}$ | $3B$ |
| $\cap, \cup, -$ | $\sqrt{B(R)+B(S)}$ | $3(B(R)+3B(S))$ |
| $\Join$ | $\sqrt{max(B(R),B(S))}$ | $5(B(R)+3B(S))$ |
| $\Join$ | $\sqrt{B(R)+B(S)}$ | $3(B(R)+3B(S))$ |

