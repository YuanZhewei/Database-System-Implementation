### 通过散列划分关系

假设$h$是散列函数，并且$h$将$R$的整个元组作为参数($R$的所有属性都是散列关键字的一部分)。将关系$R$划分为大小大致相等的$M-1$个桶。第$M$个缓冲区用来每次装入一个待计算的块。

### 基于散列的消除重复算法

将$R$散列到$M-1$个桶，在该桶中独立的执行$\delta$，并且将$\delta(R_i)$的并作为结果，其中$R_i$是$R_i$散列到第$i$个桶的那一部分。

要求$R_i$小到装入内存而允许使用一趟算法。即$\frac{B}{M-1} \le M$，近似为$B \le M^2$
散列元组时，$R$的每一块被读取一次，并被写入磁盘。然后针对每个桶的一趟算法，我们再读取一次。因此，磁盘I/O的总数量为$3B$

### 基于散列的分组和聚集算法

将$R$散列到$M-1$个桶，在该桶中独立的执行$\gamma$

和$\delta$相同，要求$B \le M^2$，磁盘I/O总数量为$3B$

在第二趟中，处理每个桶时仅需要每组一个记录。因此，即使桶的大小大于$M$，只要桶内所有分组的记录需要的缓冲区数不超过$M$，我们就可以在一趟中处理该桶。因此，如果分组很少，那么实际能处理的关系比$B \le M^2$规则所指的要大

### 基于散列的并、交、差算法

* $R\cup_SS$将$R$和$S$各自散列到$M-1$个桶，例如$R_1,R_2,\ldots,R_{M-1}$和$S_1,S_2,\ldots,S_{M-1}$，然后对于所有$i$我们计算$R_i$和$S_i$的集合并，并输出结果
* $R\cup_SS$简单的包并算法即可，不比引入散列
* 计算$R$和$S$的交或差，像集合并一样分别散列到$M-1$个桶，并在每个$R_i$和$S_i$上执行一趟算法。
所有一趟算法需要$B(R) + B(S)$次磁盘I/O，加上每个块散列的两次磁盘I/O，一共是$3(B(R)+B(S))$
为了使算法可行，必须使$R_i$和$S_i$的一趟算法可行，$min(\frac{B(R)}{M-1}, \frac{B(S)}{M-1}) \le M-1$，近似于$min(B(R), B(S)) \le M^2$

### 散列连接算法

将$R$和$S$各自散列到$M-1$个桶，例如$R_1,R_2,\ldots,R_{M-1}$和$S_1,S_2,\ldots,S_{M-1}$，然后对于所有$i$我们计算$R_i$和$S_i$的连接，并输出结果

* 需要$3(B(R)+B(S))$次磁盘I/O来完成任务
* 要求$min(B(R),B(S)) \le M^2$

### 优化散列连接算法

在第一趟时，如果可用内存比桶数多，则可能节省磁盘I/O。

#### 混合散列连接

假设要做连接$R\Join S$，$S$是较小的关系，需要建立$k$个桶，$k$远小于$M$。散列时，可以将$k$个桶中的$m$个完全保留在内存中，对于其他$k-m$个桶，每个只在内存中保留一个块。只要内存中的桶的预计大小加上其他每个桶的一个块不超过$M$，即：
$$
\frac{mB(S)}{k} + k - m \le M
$$
即可做到这一点。一个桶的预期大小是$\frac{B(S)}{k}$，并且有$m$个桶在内存中。

现在我们读取另一个关系$R$的元组，以将这个关系散列到桶中时，我们在内存中保留：
1.	$S$的$m$个从未写到磁盘中的桶
	.	$R$的$k-m$个桶中每一个的一块，这$k-m$个桶对应的$S$桶是写到磁盘上的

如果$R$的一个元组$t$散列到最开始的$m$个桶得有一个里，那么立刻将它和对应$S$桶的元祖的连接。如果$t$散列到对应的$S$桶位于磁盘上的某个桶中，那么将$t$写入对应的内存块中，并最终写入磁盘。
在第二趟中，连接$k-m$个不在内存中的桶
对于留在内存中的$S$和$R$桶中的每一个块，节省的磁盘I/O为$2$，因为在内存中占的比例为$\frac{m}{k}$，所以节省$2 \frac{m}{k}(B(R)+B(S))$。
在$m$等于$1$，且$k$尽可能小的情况下，节省I/O最多。
需要使桶的大小稍小于$\frac{B(S)}{M}$，$k$约等于$\frac{B(S)}{M}$，$m$等于$1$，节省的磁盘I/O
$$
\frac{2M(B(R)+B(S))}{B(S)}
$$

总代价为
$$
(3 - \frac{2M}{B(S)})(B(R)+B(S)))
$$

例 连接$R$和$S$，$M=101$，$B(R)=1000$，$B(S)=500$，则$k \approx \frac{500}{101}$，假设选定$k = 5$，那么，平均每个桶将拥有$S$的$100$个块。则需要$100 + 4$个块，少于$M$。
所以选择$k = 6$，则$m = 101 - 5 = 96$，桶的大小的预期为$\frac{500}{6} = 83$，第一趟处理$S的所有内容，$500$个读取I/O，将$500 - 83$个块写入磁盘，即$417$个写入I/O，第一趟处理$R$时，$1000$次磁盘I/O，并将$1000$个块的$\frac{5}{6}$写入到磁盘上，即$833$个写入I/O
第二趟中，读取磁盘上所有的桶，所以一共需要$500 + 1000 + 2 \times (417 + 833) = 4000$次磁盘I/O，少于直接散列的$4500$次磁盘I/O。
### 基于散列的算法的比较

|     操作符      | 大致需要的$M$ |             磁盘I/O              |
| :-------------: | :-----------: | :------------------------------: |
| $\gamma,\delta$ |  $\sqrt{B}$   |               $3B$               |
| $\cap, \cup, -$ | $\sqrt{B(S)}$ |         $3(B(R) + B(S)$          |
|     $\Join$     | $\sqrt{B(S)}$ |         $3(B(R) + B(S)$          |
|     $\Join$     | $\sqrt{B(S)}$ | $(3-\frac{2M}{B(S)})(B(R)+B(S))$ |

1. 二元操作的基于散列的算法仅依赖于两个操作对象中大小较小的一个，而不像基于排序的算法是两个操作对象大小之和。

2. 基于排序的算法产生一个有序的结果，可能作为后续操作符的另一个基于排序的算法使用。

3. 基于散列的算法依赖于大小相同的桶。由于通常在大小上至少有较小的差异，因此不可能平均占用$M$块的桶，我们必须将他们限制在一个较小的数字。如果不同关键字的数量小时，这一现象尤为显著。

4. 在基于排序的算法中，如果适当的组织磁盘，排序子表可能会被写到磁盘上连续的块中。因此，每个块的3次磁盘I/O的一个可能需要较短的旋转延迟和检索时间，所以可能比基于散列的算法快得多。

5. 此外，如果$M$比排序子表的数量大的多，那么，我们可以从一个排序子表一次读一些连续的块，再一次节省一些延迟和检索的时间。

6. 在基于散列的算法中，如果能选择的桶的数量小于$M$，那么，我们可以一次写出一个桶的多个块。可以得到与基于排序的算法的相同的收益。同时我们可以组织磁盘使得一个桶处于磁道连续的块上，这样桶可以用较短的延迟和检索时间来读取。

   