##基于索引的算法

### 聚簇和非聚簇索引

如果一个关系的元组能紧缩到存储这些元组的尽可能少的块中，那么这个关系就是聚簇的。

在一个或多个属性上的聚簇索引，具有这个索引查询关键字的一个固定值的所有元组都出现在能容纳它们的尽可能少的块中。

一个非聚簇的关系不能拥有一个聚簇索引，一个聚簇的关系可以有非聚簇索引。

### 基于索引的选择

$\sigma_C(R)$

关系$R$是聚簇的，I/O就是$B(R)$

如果$R$不是聚簇的，I/O最高为$T(R)$

设想条件$C$是$a = v$的形式，这里的$a$是一个存在着索引的属性，$v$是一个常量。

如果$R.a$上的索引是聚簇的，那么取回集合$\sigma_{a=v}(R)$所需的磁盘I/O大约是$\frac{B(R)}{V(R,a)}$，实际的数目可能会略高些，原因如下:

1. 通常，索引不是完全保存在内存中，需要一些磁盘I/O支持索引的载入和查找

2. 即使$a=v$的所有的元组都可以装入$b$个块中，它们可能分布在$b+1$个块中

3. 尽管$R$关系的元组时聚簇的，它们不可能尽可能的填满块。例如，元组有额外的空间以便以后往$R$中插入元组，或者$R$存在聚簇文件中

如果$R.a$上的索引是非聚簇的，$\frac{T(R)}{V(R,a)}$

### 使用索引的连接

假设$S$有一个属性$Y$上的索引。计算连接的方法是检查$R$上的每一个块，并在每一个块中考虑每一个元组$t$。令$t_Y$是对应于属性$Y$的部分。使用索引来查找$S$中所有在$Y$部分上具有$t_Y$的元组，输出这些元组与$t$的连接。

对于$R$的每一个元组，平均读取$S$的$\frac{T(S)}{V(S,Y)}$个元组。如果$S$在$Y$上有一个非聚簇的索引，那么所需的磁盘I/O数量是$\frac{T(R)T(S)}{V(S,Y)}$，如果索引是聚簇的，那么$\frac{T(R)B(S))}{V(S,Y)}$就够了。

不管$R$是否聚簇，访问$S$的元组的代价是占主导地位的，忽略读入$R$的代价，代价分别为非聚簇的$\frac{T(R)T(S)}{V(S,Y)}$和聚簇的$T(R)(1,\frac{B(S))}{V(S,Y)})$

### 使用有序索引的连接

执行基于排序的连接的最后一步即可，代价为$B(R)+B(S)$