## 使用超过两趟的算法

### 基于排序的多趟算法

假设有$M$个缓冲区来对$R$进行排序，假设$R$是按聚簇存储的，那么可以按如下方式做

**基础** 如果$R$可装入$M$个块中($B(R) \le M$)，那么将$R$装入内存，排序。

**归纳** 如果$R$不能装入内存，将$R$的块分为$M$个组，称作$R_1, R_2, \ldots,R_M$。对每个$i = 1, 2, \ldots, M$，递归的将$R_i$进行排序。接着，将$M$个子表合并。

### 基于排序的多趟算法的性能

令$s(M, k)$是使用$M$个缓冲区和$k$趟能排序的最大关系的大小。可以按如下方法计算$s(M, k)$：

**基础** 如果 $k=1$，即允许一趟，那么有$B(R) \le M$，即$s(M,1) = M$

**归纳** 假如$k > 1$，那么将$R$分成$M$片，每一片必须通过$k-1$趟排序。如果$B(R)=s(M,k)$，则$R$的$M$个片的每一片的大小$\frac{s(M,k)}{M}$，不能超过$s(M,k-1)$，即$s(M,k)=Ms(M,k-1)$

展开递归：
$$
s(M,k) = Ms(M,k-1) = M^2s(M,k-2)=\dots=M^{k-1}s(M,1) = M^k
$$
得到$B(R)\le M^k$，那么通过$k$趟，我们可以将关系$R$排序。

排序算法每一趟从磁盘读取所有数据并写回，这样，一个$k$趟排序算法需要$2kB(R)$次磁盘I/O。

考虑$R(X,Y)\Join S(Y,Z)$。令$j(M,k)$是$k$趟的，使用$M$个缓冲区的最大的块数

$$
B(R) + B(S) \le M^k
$$

使用$(2k-1)(B(R) + B(S))$次磁盘I/O
### 基于散列的多趟算法

**基础** 对于一元操作，如果关系能装到$M$个缓冲区中，将它读入内存并执行操作。对于二元操作，如果有一个关系能装入$M-1$个缓冲区中，将这个关系读入内存，再将第二个关系一次一块地装入第$M$个缓冲区。

**归纳** 如果没有一个关系能装入内存，那么将关系散列到$M-1$个桶中。在每个桶或每个相对应的桶递归的执行操作，并将每个桶或桶对的输出积累起来。

### 基于散列的多趟算法的性能

考虑一元操作，例如在关系$R$上使用$M$个缓冲区的$\delta, \gamma$。令$u(M,k)$是$k$趟散列算法能够处理的最大的关系的块数。

**基础** $u(M,1) = M$，因为关系$R$必须能装入到$M$个缓冲区中，即$B(R) \le M$

**归纳** 假设第一步将$R$分到$M-1$个大小相同的桶中。则，$u(M,k) = (M-1)u(M,k-1)$ 。

展开递归得到$u(M,k) = M(M-1)^{k-1}$，如果$M$足够大，则近似$u(M,k)=M^k$

考虑$R(X,Y)\Join S(Y,Z)$。令$j(M,k)$是$k$趟的，使用$M$个缓冲区的最大的块数

**基础** $j(M,1) = M - 1$，如果使用一趟算法，那么$R$或者$S$一定能装入$M-1$个块中

**归纳** $j(M,k)=(M-1)j(M, k - 1)$

展开递归可得$j(M,k) = (M-1)^k$，如果$M$很大，可以近似为$j(M,k) = M^k$，$min(B(R), B(S)) \le M^k$