假设计算表达式的代价可用所执行的磁盘I/O数加以近似，磁盘I/O受以下因素影响

1. 所选取用于实现查询的特定逻辑运算符，这是选择逻辑查询计划时所选定的。
2. 中间关系的大小
3. 用于实现逻辑运算符的物理运算符，例如，对一趟或两趟连接的选择，对给定关系是否加以排序的选择
4. 相似运算的排序
5. 由一个物理运算符向下一个物理运算符传递的参数

###大小参数估计值的获取
####直方图
最常用的直方图类型是:
1. 等宽

  选定宽度$w$以及常量$v_0$ 。提供值为$v$的元组数计数，$v$的范围是$v \in [v_0, v_0+w) v \in [v_0 + w, v_0 + 2w)$，值$v_0$是最小可能值或当前所知的下界。在后一种情况，若见到一个新的更小的值，我们把$v_0$减少$w$并在直方图中增加一个计数

2. 等高

   高度相同，$x$轴宽度不同

3. 最频值

   列出出现频次最高的值和他们的频次

例：考虑3个最频值及其计数，以及对其余值进行分组的直方图。假设我们想要计算连接$R(a, b) \Join S(b, c)$，令$R.b$的直方图是
$$
1:200 \ 0:150 \ 5:100 \ other:550
$$
$S.b$的直方图是
$$
0:100 \ 1:80 \ 2:70 \ other:250
$$
并假设$V(R, b) = 14, V(S, b)=13$

$$
R(a, b) \Join_{b = 0} S(b, c) = 150 \times 100 = 15000 \\
R(a, b) \Join_{b = 1} S(b, c) = 200 \times 80 = 16000 \\
R(a, b) \Join_{b = 2} S(b, c) = \frac{550}{11} \times 70 = 3500 \\
R(a, b) \Join_{b = 5} S(b, c) = 100 \times \frac{250}{10} = 2500 \\
R(a, b) \Join_{other} S(b, c) = \frac{550}{11} \times \frac{250}{10} \times 9 = 11250 \\
R(a, b) \Join S(b, c) = 15000 + 16000 + 3500 + 2500 + 11250 = 48250
$$

例： 假定直方图等宽，两个关系的值几乎不相交

```sql
Jan(day, temp)
July(day, temp)

select Jan.day, July.day
from Jan, July
where Jan.temp = July.temp;
```

假定直方图如下

|  范围   | 1月  | 7月  |
| :-----: | :--: | :--: |
| $0 \sim 9$  |  $40$  |  $0$ |
| $10 \sim 19$ |  $60$  |  $0$   |
| $20 \sim 29$ |  $80$  |  $0$   |
| $30 \sim 39$ |  $50$  |  $0$   |
| $40 \sim 49$ |  $10$  |  $5$   |
| $50 \sim 59$ |  $5$   |  $20$  |
| $60 \sim 69$ |  $0$   |  $50$  |
| $70 \sim 79$ |  $0$   | $100$  |
| $80 \sim 89$ |  $0$   |  $60$  |
| $90 \sim 99$ |  $0$   |  $10$  |

如果相应带宽分别有$T_1$与$T_2$个元组，且在这一带宽中值的个数是$V$，则在那些带宽上的连接的元组数估计是$\frac{T_1T_2}{V}$
$$
Jan(day, temp) \Join July(day, temp) \\
\Downarrow \\
Jan(day, temp) \Join_{tmp \in [40, 49]} July(day, temp) + Jan(day, temp) \Join_{tmp \in [50, 59]} July(day, temp) \\
\Downarrow \\
10 \times 5 \div 10 + 5 \times 20 \div 10 = 15
$$
如果我们没有直方图，只知道每个关系有$245$个元组分布于$0 \sim 99$的100个值中，则对连接大小的估计为$245 \times 245 \div 100 = 600$个元组。

###统计量的计算
在查询优化中，统计量通常仅是周期性地加以计算，原因如下
1. 这些统计量短时间内不会发生剧烈变化
2. 即使不太准确的统计量也是有用的，只要他们被一致的应用到所有的计划中
3. 另一个可选的办法是保持统计量为当前最新状态
### 减少逻辑查询计划代价的启发式估计

$\delta(\sigma_{a=10}(R \Join S))$
|   $R(a, b)$    |    $S(b,c)$    |
| :------------: | :------------: |
| $T(R) = 5000$  | $T(S) = 2000$  |
| $V(R,a) = 50$  |                |
| $V(R,b) = 100$ | $V(S,b) = 200$ |
|                | $V(S,c) = 100$ |

下推后
$\delta(\sigma_{a=10}(R)) \Join \delta(S)$ 或 $\delta(\sigma_{a=10}(R) \Join S)$
$\delta(\sigma_{a=10}(R)) \Join \delta(S)$ 
------
$$
T(\sigma_{a=10}(R)) = \frac{T(R)}{V(R,a)} = 5000 \div 50 = 100 \\
T(\delta(\sigma_{a=10}(R))) = \frac {T(\sigma_{a=10}(R))}{2} = 50 \\
T(\delta(S)) = \frac{T(S)}{2} = 1000 \\
T(\delta(\sigma_{a=10}(R)) \Join \delta(S)) = T(\delta(\sigma_{a=10}(R))) \times T(\delta(S)) \div max(V(R,b), V(S, b)) \\
\Downarrow \\
50 \times 1000 \div 200 = 250 \\
\sum = 100 + 50 + 1000 = 1150
$$
$\delta(\sigma_{a=10}(R) \Join S)$
------
$$
T(\sigma_{a=10}(R)) = \frac{T(R)}{V(R,a)} = 5000 \div 50 = 100 \\
T(\sigma_{a=10}(R) \Join S) = T(\sigma_{a=10}(R)) \times T(R) \div max(V(R,b), V(S,b)) = 100 \times 2000 \div 200 = 1000 \\
T(\delta(\sigma_{a=10}(R) \Join S)) = \frac{T(\sigma_{a=10}(R) \Join S)}{2} = 1000 \div 2 = 500 \\
\sum = 100 + 1000 = 1100
$$

我们把根节点和叶节点之外的所有大小估计相加，我们排除根节点和叶节点，是因为这些节点的大小不依赖于计划的选取。计划a的大小为1150，计划b的大小为1100
###枚举物理计划的方法
底线为穷举法(exhaustive)
* 自顶向下 - 递归
* 自底向上 - DP
####启发式
常用启发规则
1. 如果逻辑计划选择需要选择$\sigma_{A=c}(R)$，且保存的关系$R$在属性$A$上有索引，则执行一个索引扫描，获得$A$值等于$c$的$R$元组
2. 更一般地，如果选择涉及上面$A=c$那样的一个条件及其他条件，我们先进行一次索引扫描，然后对元组进一步选择，我们将用物理运算符$filter$来表示
3. 如果连接的一个参数在连接属性上有索引，则采用内层连接，其中该关系在内层循环中
4. 如果连接的一个参数是排序的，则采用排序连接比散列连接好
5. 当计算两个以上关系的交或并时，先对最小关系进行组合
####分支界定计划枚举
即剪枝法
####爬山法
从一个根据启发式选定的物理计划开始，接着我们可以对计划做小的修改，如用另一种方法替换执行一个运算符的一个方法，或通过交换律或结合律对连接重新排序，选择具有较低代价的临近计划。当我们找到一个计划，临近已经没有代价更小的计划了，则选定这个计划
####动态规划
自底向上
####Selinger风格的优化
这个方法改进了动态规划方法，不仅记录了每个子表达式的最小代价的计划，而且也记录了那些具有较高代价但所产生的结果对表达式中高层很有用的计划。例如
当子表达式的结果按以下属性排序：
1. 在根节点上排序$\Gamma$运算符中说明的属性

2. 稍后的分组运算符$\gamma$的分组属性

3. 稍后的连接运算的连接属性

如果我们把一个计划的代价视为中间关系大小之和，则对一个参数进行排序似乎没有什么优点。然而，如果我们使用更准确的度量，如磁盘I/O数作为代价，当我们使用基于排序的算法对某参数进行排序，其优点就变得清晰了，为已排序的参数节省了第一趟工作。