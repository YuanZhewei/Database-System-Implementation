### 选取一个选择方法

$\sigma_C(R)$，假定至少有一个条件是$A\theta c$的形式，其中$A$是一个有索引的属性，$c$是一个常数，并且是一个比较运算符$=$或$<$

每个物理计划使用一些属性，这些属性：

1. 有一个索引。
2. 与选择项之一的一个常量相比较。

以下讨论限制在以下的算法：

1. 采用索引扫描物理操作，对所有元组进行检索。
2. 考虑选中的每个元组，看它是否满足剩下的选择条件。执行这一步的物理操作叫过滤器。

为了比较不同算法的代价，不能继续使用经过简化的中间关系大小的代价估计。原因是这一步考虑逻辑查询计划的单一步骤的执行，并且中间关系与具体执行是相互独立的。

假设操作是$\sigma_C(R)$，其中$C$是一个或多个项的$AND$。

1. 表扫描算法与一个过滤器步骤相结合的代价是：
   1. 如果$R$被聚集，则为$B(R)$
   2. 如果$R$没有被聚集，则为$T(R)$
2. 选出一个等值选项，例如$a=10$，存在关于属性$a$的索引，并且利用索引扫描来找出匹配的元组，然后将被浏览的元组进行过滤来看他们是否满足全部条件$C$，这样一个算法的代价是:
   1. 如果索引是聚集的，为$\frac{B(R)}{V(R,a)}$
   2. 如果索引不是聚集的，则为$\frac{T(R)}{V(R,a)}$
3. 选出一个不等值选项，例如$b < 20$，存在关于属性$b$的索引，并且利用索引扫描来搜索匹配元组，然后将被浏览的元组进行过滤来看它们是否满足全部条件$C$，这样一个计划的代价是：
   1. 如果索引是聚集的，则为$\frac{B(R)}{3}$
   2. 如果索引不是聚集的，则为$\frac{T(R)}{3}$

### 选择连接方法

如果不清楚查询可用的缓冲区的容量，或者没有重要的大小参数，如$V(R,a)$的估计值，则仍有一些重要的原则供来选择一个连接方法。同样的思想适用与其他二元运算，例如并，以及完全关系、一元运算符、$\gamma$和$\delta$

* 一个方法是调用一趟连接，希望缓冲区管理器可以为连接分配足够的缓冲区，或者缓冲区管理器可以关闭，所以颠簸不是一个主要的代价。另一个可替代的方法(只用于连接，而不用于其他二元运算符)是选择一个嵌套循环连接，希望如果不能保证为左参数分配足够的缓冲区立刻装入内存，则参数将不会被分解成太多的片，并且连接结果将仍是合理和有效的。

* 当以下两点的任意一点成立时排序连接就是一个好的选择：

  * 一个或两个参数已经在它们的连接属性上排序。

  * 对于同样的属性有两个或多个连接，例如
    $$
    (R(a,b) \Join S(a,c)) \Join T(a,d)
    $$
    其中基于$a$对$R$和$S$进行排序将会引起$R \Join S$的结果在$a$上被排序，并且在第二个排序连接中被直接使用。

* 如果有一个索引的的机会，例如一个连接$R(a,b) \Join S(b,c)$，其中$R$被期望是很小的(也许是基于键的一个选择，它的结果是一个元组)，并且有一个连接属性$S.b$上的索引，则我们应该选择一个索引连接。

* 如果没有机会利用已经排序的关系或索引，并且需要多遍连接，则散列连接也许是最佳选择，因为它所需要的扫描次数取决于较小参数的大小而不是两个参数的大小。
###流水操作与物化

执行一个查询计划的原始方法是对运算进行适当的排序(即直到位于一个运算下面的参数已经被执行后它才执行)，并且将每个运算的结果存储在磁盘上直到它被另一个运算所需要。这个策略叫做**物化**，因为每个中间关系在磁盘上被物化。

执行一个查询计划的一个更巧妙、更有效的方法是一次同时交错进行几个运算。由一个运算产生的元组直接传递给使用它的运算，不需要将中间元组存储在磁盘上。这个方法叫**流水操作**，一般由一个迭代器网络执行，该迭代器网络的方法在适当的时候互相调用。流水操作也有缺点，由于任何时候几个运算必须共享内存，就有可能必须选择更高磁盘I/O需求的算法，或者将会发生颠簸，从而耗费由流水操作所节省的所有磁盘I/O，甚至可能更多。

### 一元流水运算

通过迭代器来执行一个一元流水操作，每次需要另一个元组时，流水操作结果的消费者就调用$GetNext()$。在投影的情况下，只需要对元组调用$GetNext()$一次，对那个元组进行适当的投影，并将结果返回给消费者。

对于选择$\sigma_C$(从技术上是物理操作$Filter(C)$)，也许需要对调用$GetNext()$若干次，知道找到一个满足$C$的元组。

### 二元运算的流水操作

二元运算的结果也可以进行流水操作。利用一个缓冲区将结果传递给消费者，一次一块。然后，计算结果和消费结果所需的其他缓冲区数目是不同的，他们取决于结果的大小及参数的大小。

例 考虑下列表达式的物理查询计划
$$
(R(w,x) \Join S(x,y)) \Join U(y, z)
$$
假设：

1. $B(R)= 5000 \ B(S) = B(U) = 10000$

2. 中间结果$R\Join S$占$k$块

3. 将两个连接作为散列连接来执行，或者是一趟连接或者两趟连接，这取决于$k$。

4. 有$101$个可用的缓冲区。这个数目，人为地被设得较低。

首先考虑连接$R\Join S$。在主存中没有任何关系存在，所以我们需要一个两趟的散列连接。如果较小关系在第一趟$R$被分成最大的可能值$100$块，那么每个$R$的桶占据$50$块。如果$R$的桶中有$50$块。如果$R$的桶有$50$块，则散列连接$R \Join S$的第二趟将使用$51$个缓冲区，其中$50$个缓冲区用于$R \Join S$的结果与$U$的连接。

假设$k \le 49$，即$R \Join S$的结果最多占用$49$块。那么我们可以将$R \Join S$的结果流水操作进入$49$个缓冲区，将它们进行组织以便作为一个散列表来查看，并且我们利用一个缓冲区来依次读入$U$的每一块。将第二趟连接作为一趟连接来执行。磁盘I/O的总数为：

1. $45000$，执行$R$和$S$的两趟散列连接

2. $10000$，在$(R\Join S) \Join U$的一趟连接中读入$U$。

总的为$55000$次磁盘I/O

现在，假设$49 < k \le 5000$。仍可将$R \Join S$的结果进行流水操作，需要使用另一个策略，在这个策略中，该关系与$U$进行一个$50$个桶的两趟散列连接。

1. 在开始$R \Join S$之前，将$U$装进$50$个桶，每个$200$块。
2. 接下来，像之前一样用$51$个桶对$R$和$S$进行一个两趟的散列连接，但是当$R \Join S$的每个元组产生时，将它放入用于形成$50$桶来将$R \Join S$和$U$进行连接的$50$个剩余缓冲区中的一个。当这些缓冲区装满时就写入磁盘，对一个两趟散列连接来说这事很正常的。
3. 最后，将$R \Join S$和$U$进行连接。由于$k \le 5000$，$R \Join S$的桶的大小最多为$100$块，因此这个连接是可行的。$U$的桶的大小为$200$块这不是一个问题，因为在桶的一趟连接中，用$R \Join S$作为构造用关系，而$U$的桶作为探查用关系。磁盘I/O总数为：
   1. $20000$，用于读取$U$并将它的元组写入桶。
   2. $45000$，用于执行$R \Join S$的两趟散列连接。
   3. $k$用于写出$R \Join S$的桶。
   4. $k + 10000$用于读取最终连接中的$R \Join S$和$U$的桶。

全部代价为$75000 + 2k$

假设$k > 5000$

如果$R \Join S$的结果被流水操作，则不能在得到的$50$个桶中执行一个两趟连接。可以使用一个三趟连接，那样的话一个参数的每块需要额外的两次磁盘I/O，或者$20000 + 2k$个更多的磁盘I/O。如果改为不对$R \Join S$进行流水操作，则可做的更好。要点如下：

1. 用一个两趟散列连接计算$R \Join S$，并将结果存储在磁盘。

2. 将$R \Join S$和$U$进行连接，仍然使用一个两趟连接。由于$B(U)=10000$，可以使用100个桶进行一趟散列连接，而不考虑$k$的大小。如果用$U$作为散列连接的构造用关系，那么$U$应作为连接中的左参数。

   磁盘I/O为：

   1. $45000$，用于$R \Join S$的两趟连接。
   2. $k$，用于将$R \Join S$存储在磁盘上。
   3. $30000 + 3k$，用于$U$和$R \Join S$的两趟散列连接。

全部代价为$75000 + 4k$

|     $k$的范围     | 流水线和物化 | 最后连接的算法 | 总的磁盘I/O |
| :---------------: | :----------: | :------------: | :---------: |
|    $k \le 49$     |    流水线    |      一趟      |   $55000$   |
| $49 < k \le 5000$ |    流水线    |      $50$个桶，两趟      | $75000+2k$ |
|    $k > 5000$     | 物化 | $100$个桶，两趟 | $75000+4k$ |

### 物理查询计划的符号

一般来说，逻辑计划的每个运算符称为物理计划的一个或多个运算符，逻辑计划的叶子称为物理计划的适用于那个关系的一个扫描运算符。

#### 叶子的运算符

1. $TableScan(R)$：以任意顺序读入所有存放$R$的元组的块
2. $SortScan(R, L)$：按照顺序读入$R$的元组，并以$L$中的属性进行排序
3. $IndexScan(R,C)$：这里$C$是形如$A\theta c$的一个条件，其中$A$是$R$的一个属性，$\theta$是一个比较运算符例如$=$或者$<$，$c$是一个常量。可以通过属性$A$上的一个索引来访问$R$的元组。如果比较运算符$\theta$不是$=$，则索引必须是一个支持范围查询的索引，例如$B$树
4. $IndexScan(R,A)$：这里$A$是$R$的一个属性，关系$R$通过$R.A$上的一个索引被检索。这个运算符看起来像$TableScan$，但如果$R$不是聚集的，该运算符也许会更有效。

#### 选择的物理运算符

1. 可以简单地用运算符$Filter(C)$代替$\sigma_C(R)$，如果$R$上没有索引，或者没有条件$C$提到的属性上的索引，则该选择是有意义的。如果选择运算的参数$R$实际上是一个被流水操作进入该选择的中间关系，则除了$Filter$以外，不需要其他的运算符。如果$R$是一个存储关系或者物化关系，则我们必须使用一个运算符($TableScan$或者$SortScan(L)$)来访问$R$。如果$\sigma_C(R)$的结果以后被传递给一个需要参数排序的运算符，则我们也许偏向于排序扫描。
2. 如果条件$C$能够被表示为$A\theta c\ AND\ D$($D$是某个其他条件)，并且有一个$R.A$上的索引，则可以：
   1. 使用运算符$IndexScan(R, A\theta c)$来访问$R$
   2. 使用$Filter(D)$来替代选择$\sigma_c(R)$

#### 物理排序运算符

一个关系的排序可能发生在物理查询计划中任何一点。一般使用一个显式的物理运算符$Sort(L)$来对没有排序的一个操作对象关系进行排序。

####其他关系代数运算

1. 被执行的运算。例如，并或分组。
2. 必不可少的参数，例如，$\theta$连接中条件或分组中的元素列表
3. 算法的一般策略：基于排序的、基于散列的，或者基于索引的，等等。
4. 关于要用到的遍历数的一个决定：一趟，两趟，多趟
5. 操作所需的预期缓冲区数。

###物理运算的排序

1. 在每一条表示物化的边处将树分解为子树。子树将一次一个地被执行。

2. 以从下到上，从左到右的顺序依次执行各子树，即执行树的前序遍历。

3. 使用一个迭代器网络来执行每一棵子树的所有节点。因此，在一棵子树中所有的节点被同步地执行，在它们的运算符间用$GetNext$调用来决定事件的确切顺序。

   根据这个顺序，查询优化现在能够为查询生成执行代码，也许是一个函数调用序列。