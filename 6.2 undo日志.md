### 日志记录

各种日志记录公有的记录形式有以下几种形式：

1. $<START \ T>$：表示事务$T$已开始
2. $<COMMIT \ T>$：事务$T$已成功完成并对数据库元素不会再有修改。$T$对数据库所做的任何更新都反映到磁盘上。然而由于缓冲区管理器决定何时将块从主存写入磁盘是不确定的，当看到$<COMMIT\ T>$日志记录时，并不能确认更新已经在磁盘上。如果我们坚持更新已经在磁盘上，那么这一要求必须由日志管理器来体现。
3. $<ABORT\ T>$：事务$T$不能成功完成。如果事务$T$中止，它所做的更新都不能拷贝到磁盘上，并且事务管理器有责任保证这样的更新绝不出现在磁盘上，或者如果已经出现就要消除对磁盘的影响。

对undo日志而言，唯一需要的其他日志记录类型是**更新日志**，更新日志是一个三元组$<T, X, v>$。这一记录的含义是：事务$T$改变了数据库元素$X$，而$X$原来的值是$v$。更新记录所反映的改变通常发生在主存上而不是磁盘上；即日志记录是对写入内存的$WRITE$动作做出的反应，而不是对写入磁盘$OUTPUT$动作做出的反应。

### undo日志规则

只要事务和缓冲区管理器遵从以下两条规则，undo日志就能保证从系统故障中恢复。

$U_1$：如果事务$T$改变了数据库元素$X$，那么形如$<T, X, v>$的日志记录必须在$X$的新值写到磁盘之前写到磁盘中。

$U_2$：如果事务提交，则其$COMMIT$日志记录必须在事务改变的所有数据库元素先写到磁盘之后后写到磁盘中，但应尽快。

简要概括规则$U_1$和$U_2$，与一个事务相关的内容必须按如下顺序写到磁盘：

1. 指明所改变数据库元素的日志记录
2. 改变数据库元素自身
3. COMMIT的日志记录

1和2的顺序是对各个数据库元素单独适用，而不是对事务的更新记录集合整个适用。

为了强制将日志记录写到磁盘上，日志记录需要一条**刷新日志**命令来告诉缓冲区管理器将以前没有刷新到磁盘的日志记录从上一次刷新以来发生修改的日志记录刷新到磁盘。在动作的序列中，我们将显式地给出$FLUSH\ LOG$。事务管理器还需要以某种方式告诉缓冲区管理器在某个数据库元素上执行$OUTPUT$动作。

例：数据库中包含两个元素$A$和$B$，这两个元素要满足的约束是在任何一致的状态中它们的值相等。

事务$T$逻辑上由下述两步构成
$$
A := A * 2; \\
B := B * 2;
$$

| 步骤 |     动作      | $t$  | $M-A$ | $M-B$ | $D-A$ | $D-B$ |     日志      |
| :--: | :-----------: | :--: | :---: | :---: | :---: | :---: | :-----------: |
| $1$  |               |      |       |       |       |       | $<START\ T>$  |
| $2$  | $READ(A, t)$  | $8$  |  $8$  |       |  $8$  |  $8$  |               |
| $3$  | $t := t * 2$  | $16$ |  $8$  |       |  $8$  |  $8$  |               |
| $4$  | $WHERE(A, t)$ | $16$ | $16$  |       |  $8$  |  $8$  |  $<T, A, 8>$  |
| $5$  | $READ(B, t)$  | $8$  | $16$  |  $8$  |  $8$  |  $8$  |               |
| $6$  | $t := t * 2$  | $16$ | $16$  |  $8$  |  $8$  |  $8$  |               |
| $7$  | $WHERE(B, t)$ | $16$ | $16$  | $16$  |  $8$  |  $8$  |  $<T, B, 8>$  |
| $8$  | $FLUSH\ LOG$  |      |       |       |       |       |               |
| $9$  |  $OUTPUT(A)$  | $16$ | $16$  | $16$  | $16$  |  $8$  |               |
| $10$ |  $OUTPUT(B)$  | $16$ | $16$  | $16$  | $16$  | $16$  |               |
| $11$ |               |      |       |       |       |       | $<COMMIT\ T>$ |
| $12$ | $FLUSH\ LOG$  |      |       |       |       |       |               |

### 使用undo日志的恢复

假设系统故障发生了，可能给定事务的某些更新已经写到磁盘上，而同一事务的其他更新尚未到达磁盘。这样的话，事务的执行就不是原子的，数据库状态就可能不一致。**回复管理器**必须使用日志来将数据库恢复到某个一致的状态。

**恢复管理器**的第一个任务是将事务划分为已提交事务和未提交事务。如果有日志记录$<COMMIT\ T>$，那么根据undo规则$U_2$，事务$T$的全部改变在此之前已写到磁盘上。因此当系统故障发生时，$T$自身不可能使数据库处于不一致的状态。

假设在日志上发现了$<START\ T>$记录，但未发现$<COMMIT\ T>$记录，那么有可能在崩溃前$T$对数据库所做的某些修改已经写到磁盘上，而$T$的其他修改还没落盘。这种情况下，$T$是一个**未完成的事务**因而必须**被撤销**。$T$所做的任何改变都必须重置为其原有的值。恢复时为数据库元素$X$写入值$v$，不必检查$X$在数据库中的值是否为$v$。

由于日志中可能有多个未提交的事务，并且甚至多个未提交的事务修改了$X$，所以恢复值的顺序必须是有计划的。恢复管理器必须从尾部开始扫描日志。扫描过程中，恢复管理器记住所有$<COMMIT\ T>$或$<ABORT\ T>$记录的事务$T$。同时在其向后扫描过程中，如果遇到记录$<T,X,v>$则：

1. 如果$T$的$COMMIT$记录被扫描到，则什么也不做。$T$已经被提交而不需要撤销。

2. 否则，$T​$是一个未完成的事务或者一个中止的事务。恢复管理器必须将数据库中$X​$的值改为$v​$。

做好这些改变后，恢复管理器必须为以前未中止的且未完成的每个事务$T$写入一个日志记录$<ABORT\ T>$，然后刷新日志。之后数据库恢复正常。

#### 恢复过程中的崩溃

假设从上一次崩溃中恢复时系统又一次崩溃。由于undo日志记录的设计方式，所给的是旧值而不是数据库元素值 的改变，因此恢复步骤是幂等的。

### 检查点

恢复原则上需要检查整个日志。当采用undo类型的日志时，一旦事务的$COMMIT$日志被写到磁盘上，该事务的日志记录在恢复时就不再需要。在$COMMIT$前删除日志是不可行的，原因在于常常是多个事务同时在执行。如果一个事务提交后将日志截断，关于其他某个活跃事务$T$的日志记录就会丢失，因而不能在需要恢复时用来撤销$T$。

解决问题的最简单的方法是周期性的对日志做**检查点**。在一个简单的检查点中，可以：

1. 停止接收新的事务。
2. 等到所有当前活跃的事务提交或中止并且在日志中写入了$COMMIT$或$ABORT$日志。
3. 将日志刷新到磁盘。
4. 写入日志记录$<CKPT>$，并再次刷新日志。
5. 重新开始接收事务。

所有在检查点前执行的事务已经完成，并且根据$U_2$其更新已经到达磁盘。因此，恢复时这些事务中的任何一个都不需要撤销。在恢复中，从日志尾部开始扫描，确定未完成的事务，当看到$<CKPT>$记录时，即可停止。

###非静止检查点

检查点技术的一个问题是，检查点会暂停系统。**非静止检查点**在系统创建检查点时允许新事务进入。

非静止检查点的步骤包括：

1. 写入日志记录$<START\ CKPT(T_1,\ldots, T_k)>$并刷新日志。其中$T_1,\ldots,T_k$是所有活跃事务(即尚未提交和将其修改写到磁盘的事务)的名字或标识符。
2. 等待$T_1,\ldots,T_k$中所有的事务提交或中止，但允许其他事务开始。
3. 当$T_1,\ldots,T_k$都已完成时，写入日志记录$<END\ CKPT>$并刷新日志。

####非静止检查点恢复

* 如果先遇到$<END\ CKPT>$记录，那么所有未完成事务在前一$<START\ CKPT(T_1,\ldots,T_k)>$记录后开始。
* 如果先遇到$<START\ CKPT(T_1,\ldots,T_k)>$，那么崩溃发生在检查点发生过程中。未完成的事务包括到达$START\ CKPT$前遇到的那些以及$T_1,\ldots,T_k$中发生在崩溃前还没有完成的那些。因此，扫描到$T_1,\ldots,T_k$中最早开始的事务的开始后就不必向前扫描。
* 一旦$<END\ CKPT>$记录写到了磁盘，上一个$<START\ CKPT(T_1,\ldots,T_k)>$记录前的日志就可以被删除。