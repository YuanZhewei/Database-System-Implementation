#### uedo日志的问题

undo日志有一个潜在的问题，即在事务改变的所有数据写到磁盘前不能提交该事务。

使用redo日志可以避免立刻将数据写到磁盘的要求。redo日志和undo日志的主要区别是：

1. undo日志在恢复时消除未完成事务的影响并忽略已提交事务，而redo日志忽略未完成的事务并重复已提交事务所做的改变。
2. undo日志要求被修改的数据库元素先落盘再将$COMMIT$落盘，redo日志要求$COMMIT$日志落盘后被修改的数据库元素再落盘。
3. undo日志恢复的是旧值，redo日志恢复的是新值。

###redo日志规则

在redo日志中，日志记录$<T, X, v>$的含义是事务$T$为数据库元素$X$写入新值$v$。

对于redo日志，数据和日志项到达磁盘的顺序有一条**先写日志规则**。

$R_1$：在修改磁盘上任何数据库元素$X$以前，要保证与$X$的这一修改相关所有的日志记录，包括更新记录$<T,X,v>$和$<COMMIT\ T>$记录都出现在磁盘上。

使用redo日志时，一个事务相关的写磁盘顺序为：

1. 写修改数据库元素的日志记录
2. $COMMIT$日志记录
3. 写数据库元素。

例：数据库中包含两个元素$A$和$B$，这两个元素要满足的约束是在任何一致的状态中它们的值相等。

事务$T$逻辑上由下述两步构成
$$
A := A * 2; \\
B := B * 2;
$$

| 步骤 |     动作      | $t$  | $M-A$ | $M-B$ | $D-A$ | $D-B$ |     日志      |
| :--: | :-----------: | :--: | :---: | :---: | :---: | :---: | :-----------: |
| $1$  |               |      |       |       |       |       | $<START\ T>$  |
| $2$  | $READ(A, t)$  | $8$  |  $8$  |       |  $8$  |  $8$  |               |
| $3$  | $t := t * 2$  | $16$ |  $8$  |       |  $8$  |  $8$  |               |
| $4$  | $WHERE(A, t)$ | $16$ | $16$  |       |  $8$  |  $8$  |  $<T, A, 8>$  |
| $5$  | $READ(B, t)$  | $8$  | $16$  |  $8$  |  $8$  |  $8$  |               |
| $6$  | $t := t * 2$  | $16$ | $16$  |  $8$  |  $8$  |  $8$  |               |
| $7$  | $WHERE(B, t)$ | $16$ | $16$  | $16$  |  $8$  |  $8$  |  $<T, B, 8>$  |
| $8$  |               |      |       |       |       |       | $<COMMIT\ T>$ |
| $9$  | $FLUSH\ LOG$  |      |       |       |       |       |               |
| $10$  |  $OUTPUT(A)$  | $16$ | $16$  | $16$  | $16$  |  $8$  |               |
| $11$ |  $OUTPUT(B)$  | $16$ | $16$  | $16$  | $16$  | $16$  |               |

### 使用redo日志的恢复

redo日志规则$R_1$表明，只要日志中没有$<COMMIT\ T>$记录，$T$对数据库所做的更新都没有写到磁盘上。因此，恢复时对未完成事务的处理就可以像事务$T$从未发生过一样。

1. 确定已提交的事务
2. 从首部开始扫描日志。对遇到的每一个$<T,X,v>$记录：
   1. 如果$T$是未提交的事务，则什么也不做。
   2. 如果$T$是已提交的事务，则为数据库元素$X$写入值$v$。
3. 对每个未完成的事务$T$，在日志中写入一个$<ABORT\ T>$记录并刷新日志。

### redo日志的检查点

redo日志的检查点，有一个undo日志没有的问题。由于已提交事务所做的数据库元素的改动落盘可能比事务提交的时间晚的多。因此只考虑创建检查点时活跃的事务是不够的。不管检查点是静止的还是非静止的，在检查点的开始和结束之间需要将已被提交事务修改的所有数据库元素落盘。要做到这样，需要缓冲区管理器知道那些缓冲区是脏的，还需要知道事务修改了哪些缓冲区。

另一方面，不需要等待活跃事务提交或中止就能完成检查点，因为它们不被允许在那个时候将页写回磁盘。

1. 写入日志记录$<START\ CKPT(T_1, \dots, T_k)>$，其中$T_1, \dots,T_k$是所有未提交的事务，并刷新日志。

2. 将$STAR\ CKPT$记录写入日志时所有已提交事务已经写到缓冲区但还没有写到磁盘的数据库元素写到磁盘。

3. 写入日志记录$<END\ CKPT>$并刷新日志。

例：下图为一个可能的redo日志。
$$
<START\ T_1> \\
<T_1, A, 5> \\
<START\ T_2>\\
<COMMIT\ T_1>\\
<T_2, B,10> \\
<START\ CKPT(T_2)> \\
<T_2,C,15> \\
<START T_3> \\
<T_3,D, 20> \\
<END\ CKPT> \\
<COMMIT\ T_2> \\
<COMMIT\ T_3>
$$
当开始检查点时，只有$T_2$是活跃的，但$T_1$所写的$A$的值可能已经到达磁盘。如果没有，则需要在$<END\ CKPT>$前将$A$拷贝到磁盘。

### 使用带检查点redo日志的恢复



