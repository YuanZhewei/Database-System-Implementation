### undo/redo日志缺陷

* undo日志要求数据在事务结束前写到磁盘，增加了磁盘I/O
* redo日志要求在事务提交和日志刷新前将所有修改的块保存在缓冲区中，这样可能会增加事务需要的平均缓冲区数
* 如果数据库元素不是完整的块或块集，在检查点过程中undo日志和redo日志在如何处理缓冲区方面都存在矛盾。例如，如果一个缓冲区包含被提交的事务修改过的数据库元素$A$和同一块缓冲区尚未将其$COMMIT$记录写到磁盘的事务修改过的数据库元素$B$，我们需要将数据库元素$A$写到磁盘，但规则$R_1$不允许我们将数据库元素$B$写到磁盘。

### undo/redo规则

undo/redo日志多了一种新的日志记录$<T,X,v,w>$，含义是，当事务$T$改变了数据库元素$X$的值，改前值为$v$，新值为$w$。 undo/redo日志的约束如下：

* $UR_1$：更新记录$<T, X, v, w>$必须比事务$T$在数据库元素$X$的改动先落盘

例：数据库中包含两个元素$A$和$B$，这两个元素要满足的约束是在任何一致的状态中它们的值相等。

事务$T$逻辑上由下述两步构成
$$
A := A * 2; \\
B := B * 2;
$$

| 步骤 |     动作      | $t$  | $M-A$ | $M-B$ | $D-A$ | $D-B$ |      日志       |
| :--: | :-----------: | :--: | :---: | :---: | :---: | :---: | :-------------: |
| $1$  |               |      |       |       |       |       |  $<START\ T>$   |
| $2$  | $READ(A, t)$  | $8$  |  $8$  |       |  $8$  |  $8$  |                 |
| $3$  | $t := t * 2$  | $16$ |  $8$  |       |  $8$  |  $8$  |                 |
| $4$  | $WHERE(A, t)$ | $16$ | $16$  |       |  $8$  |  $8$  | $<T, A, 8, 16>$ |
| $5$  | $READ(B, t)$  | $8$  | $16$  |  $8$  |  $8$  |  $8$  |                 |
| $6$  | $t := t * 2$  | $16$ | $16$  |  $8$  |  $8$  |  $8$  |                 |
| $7$  | $WHERE(B, t)$ | $16$ | $16$  | $16$  |  $8$  |  $8$  | $<T, B, 8, 16>$ |
| $8$  | $FLUSH\ LOG$  |      |       |       |       |       |                 |
| $9$  |  $OUTPUT(A)$  | $16$ | $16$  | $16$  | $16$  |  $8$  |                 |
| $10$ |               |      |       |       |       |       |  $<COMMIT\ T>$  |
| $11$ |  $OUTPUT(B)$  | $16$ | $16$  | $16$  | $16$  | $16$  |                 |

 第$10$步可以出现在第$8$或第$9$步之前，也可以出现在第$11$之后。

### 使用undo/redo日志恢复

1. 按照从前往后做顺序，重做所有已提交的事务。
2. 按照从后往前做顺序，撤销所有未提交的事务。

由于undo/redo日志在$COMMIT$日志记录与数据库元素写磁盘的相对顺序的灵活性，一个已提交事务的部分或全部修改在不在磁盘上都是可以的。

例：考虑上表中的动作序列

1. 假如崩溃发生在$<COMMIT\ T>$记录刷新到磁盘后，这时$T$被认为已提交。我们重新往$A$和$B$写入值$16$。由于事件实际的顺序，$A$可能为$16$，也可能不是，这取决于崩溃发生在$11$步之前还是之后。

2. 假如崩溃发生在$<COMMIT\ T>$记录刷新到磁盘前，则$T$未完成。$A$和$B$原来的值被写入磁盘。

####推迟提交的问题

和undo日志一样，使用undo/redo日志可能出现这样的行为：事务在用户看来已经提交，但由于$<COMMIT\ T>$尚未刷到磁盘，后来的一次崩溃使事务被撤销而不是重做。所以建议为undo/redo日志附加一条规则：

$UR_2$：$<COMMIT\ T>$日志一旦出现就必须刷新到磁盘上。


### undo/redo日志的检查点

undo/redo日志的非静止检查点要容易些。

1. 写入日志记录$<START\ CKPT(T_1,\ldots,T_k)>$，其中$T_1, \ldots, T_k$是活跃的事务，并刷新日志。
2. 将所有**脏缓冲区**写到磁盘，**脏缓冲区**即包括一个或多个修改过的数据库元素的缓冲区。和redo日志不同的是，我们刷新所有脏缓冲区，而不是已提交的暂缓冲区。
3. 写入日志记录$<END\ CKPT>$并刷新日志。

关于第二点，由于undo/redo日志在数据何时到达磁盘提供灵活性，我们可以容忍将未完成事务写入的数据写入磁盘。所以，我们能容忍小于完整块的数据库元素，并因此可以共享缓冲区。我们必须对事务做出的唯一要求是：

* 事务在不确定其不会中止之前不能写入任何值(甚至连写到主存缓冲区也不允许)
* 为了避免事务间不一致的相互影响，这一约束无论如何都几乎是必须的。

#### 事务在恢复中的奇怪行为

不管我们先撤销还是先重做，我们都会面临如下情况：事务$T$提交了并被重做了。然而$T$读取了一个值$X$，该值是由某个未提交并撤销的事务$U$写入的。问题不在于我们先重做，使$X$具有$U$对它写入之前的值；还是先撤销，使$X$具有由$T$写入的值，不管哪种方法，这种情况都没有意义，因为数据库的最终状态不对应于任何原子的事务序列的结果。

在实际中，DBMS必须要做的是不仅仅把改变记入日志中。它必须保证上述的情况绝对不会发生。

