简单的封锁模式过于简单而不是一个实用的模式。主要问题在于，事务$T$即使只想读数据库元素$X$而不写它，也必须获得$X$上的锁。而不获取锁，当$T$活跃时另一个事务可能为$X$写入一个新值而导致非可串行化行为。

### 共享锁和排他锁

$sl_i(X)$表示事务$T_i$申请数据库元素$X$上的一个共享锁。

$xl_i(X)$表示事务$T_i$申请数据库元素$X$上的一个排他锁。

$u_i(X)$表示事务$T_i$解锁$X$。

#### 事物的一致性

在任何事务$T_i$中：

1. 读动作$r_i(X)$之前必须有$sl_i(X)$或$xl_i(X)$，而且它们之间没有$u_i(X)$。
2. 写动作$w_i(X)$之前必须有$xl_i(X)$，而且它们之间没有$u_i(X)$。

####事务的两阶段封锁

对任意$Y$，在任何两阶段封锁事务$T_i$中，任何$sl_i(X)$或$xl_i(X)$动作前不能有$u_i(Y)$动作。

#### 调度的合法性

一个元素或者可以被一个事务排他锁封锁，或者可以被几个事务共享地封锁，但二者不能兼而有之。更精确地：

1. 如果$xl_i(X)$出现在调度中，那么对$j\ne i$，后面不能再有$xl_j(X)$或$sl_j(X)$，除非中间隔了$u_i(X)$。
2. 如果$sl_i(X)$出现在调度中，那么对$j \ne i$，后面不能再有$xl_j(X)$，除非中间隔了$u_i(X)$。

### 相容性矩阵

**相容性矩阵**是一个描述锁-管理策略的简单方法。每个封锁方式有一行和一列。行对应于数据库元素$X$上另一事务已持有的锁。而列对应于$X$上申请的锁。

|          |      | 申请的锁 | 申请的锁 |
| :------: | :--: | :------: | :------: |
|          |      |   $S$    |   $X$    |
| 持有的锁 | $S$  |    是    |    否    |
| 持有的锁 | $X$  |    否    |    否    |

###锁的升级

共享锁可升级为排他锁。

不加区别的升级可能造成死锁。

例：假设$T_1$和$T_2$分度读数据库元素$A$，并为$A$写入新值。如果两个事务都使用升级方法，首先获得$A$上的共享锁，然后将其升级为排他锁。那么只要$T_1$和$T_2$几乎同时开始，下表所示的时间序列就会发生死锁。

|      $T_1$      |      $T_2$      |
| :-------------: | :-------------: |
|    $sl_1(A)$    |                 |
|                 |    $sl_2(A)$    |
| $xl_1(A)$被拒绝 |                 |
|                 | $xl_1(A)$被拒绝 |

$T_1$和$T_2$都能得到$A$上的共享锁，接着，它们都会试图升级为排他锁，但由于另一个事务在$A$上持有共享锁，调度器迫使它们都等待，形成死锁。

### 更新锁

**更新锁**$ul_i(X)$只给予事务$T_i$读$X$而不是写$X$的权限。但是，只有更新锁能在以后升级为写锁；读锁是不能升级的。当$X$上已经有共享锁时我们可以授予$X$上的更新锁，但是一旦$X$上有了个更新锁，我们就禁止在$X$上加任何其他种类的锁。否则，更新者可能因为$X$上有其他类型的锁而导致永远没有机会升级为排他锁。

|      | $S$  | $X$  | $U$  |
| :--: | :--: | :--: | :--: |
| $S$  |  是  |  否  |  是  |
| $X$  |  否  |  否  |  否  |
| $U$  |  否  |  否  |  否  |

例：
$$
T_1:ul_1(A);r_1(A);xl_1(A);w_1(A);u_1(A); \\
T_2:ul_2(A);r_2(A);xl_s(A);w_2(A);u_2(A);
$$

|          $T_1$          |          $T_2$          |
| :---------------------: | :---------------------: |
|    $ul_1(A);r_1(A)$     |                         |
|                         |     $ul_2(A)$被拒绝     |
| $xl_1(A);w_1(A);u_1(A)$ |                         |
|                         |    $ul_2(A);r_2(A)$     |
|                         | $xl_2(A);w_2(A);u_2(A)$ |

### 增量锁

增量动作一个有用的性质是这些动作相互之间是可交换的，如果两个事务都给同一个数据库元素加上常数，谁先做谁后做是无关紧要的。另一方面，增量与读和写都不能交换；如果在$A$增加前或增加后读$A$，得到的值是不同的；如果在其他事务中为$A$写入新值以前或以后增加$A$，在数据库中也会得到不同的$A$。

$INC(A,c)$：增量动作，将**常数**$c$加到数据库元素$A$上。$c$可以为负。表示以下步骤的原子执行：
$$
READ(A,t);\ t:=t+c;\ WRITE(A,t )
$$
**增量锁**：使用$il_i(X)$表示$T_i$请求$X$上的增量锁。

|      | $S$  | $X$  | $I$  |
| :--: | :--: | :--: | :--: |
| $S$  |  是  |  否  |  否  |
| $X$  |  否  |  否  |  否  |
| $I$  |  否  |  否  |  是  |

