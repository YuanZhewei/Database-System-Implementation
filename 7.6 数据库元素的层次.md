### 多粒度的锁

不同的系统使用不同大小的数据库元素封锁、例如元组、页或块，以及关系。有的应用受益于小的数据库元素如元组，而另一些使用大的元素时好。

### 警示锁

警示锁解决管理不同粒度的问题。
数据库元素分以下三个级别：
![7-6-1](/Users/ace/z/keeplearning/7-6-1.jpg)

1. 关系是最大的可封锁元素。
2. 每个关系由一个或多个块或页组成，每个块或页上存储了关系的元组。
3. 每个块包含一个或多个元组。

在数据库元素的层次上管理锁的规则由**警示协议**构成，它既包括**普通锁**又包括**警示锁**。警示锁将通过在普通锁前面加前缀$I$表示，例如$IS$表示获得子元素上的一个共享锁的意向。警示协议的规则是：
1. 要在任何元素上加$S$或$X$锁，必须从层次结构的根开始。
2. 如果已经将要封锁的元素的位置，则不需要进一步查找，进而请求该元素上的$S$或$X$锁。
3. 如果希望封锁的元素在层次结构中更靠下，那么我们在这一节点上加一个警示锁，当前节点上的锁被授予后，我们继续向适当的子节点行进。

|      | $IS$ | $IX$ | $S$  | $X$  |
| :--: | :--: | :--: | :--: | :--: |
| $IS$ |  是  |  是  |  是  |  否  |
| $IX$ |  是  |  是  |  否  |  否  |
| $S$  |  是  |  否  |  是  |  否  |
| $X$  |  否  |  否  |  否  |  否  |

例：考虑关系
```sql
Movie(title, year, length, studioName)
```
假设事务$T_1$：
```sql
SELECT *
FROM Movie
WHERE title = 'King Kong';
```
事务$T_2$：
```sql
UPDATE Movie
SET year = 1939
WHERE title = 'Gone With the Wind';
```
锁的集合如图所示：

![7-6-2](/Users/ace/z/keeplearning/7-6-2.jpg)

### 幻象与插入的正确处理

当事务创建一个可封锁的新的子元素时，可能会出错，问题在于封锁只能封锁已有的元素，而不能封锁还不存在的元素。

例：
```sql
Movie(title, year, length, studioName)
```
事务$T_3$首先发生
```sql
SELECT SUM(length)
FROM Movie
WHERE studioName = 'Disney';
```
事务$T_3$在$Movie$关系上获得$IS$锁，在$Disney$影片的每个元组获得$S$锁。
现在$T_4$事务出现并插入一个新的$Disney$影片，看起来$T_4$不需要锁。但它使$T_3$的结果不正确。
假设$D_1$和$D_2$是原来已经存在的$Disney$影片，而$D_3$是$T_4$插入的新影片。设$L$是$T_3$计算出的结果，并假设数据库上的一致性约束是$L$应该等于最后一次计算$L$时存在的所有$Disney$影片长度之和。那么下面是警示协议下合法的一个事件序列：
$$
r_3(D_1);r_3(D_2);w_4(D_3);w_4(X);w_3(L);w_3(X);
$$
这个调度不是可串行化的。
有一种简单方法避免幻象发生，即将元组的插入或删除看做整个关系上的写操作。因此$T_4$需要在关系$Movie$上需要获得$X$锁。由于$T_3$已经以$IS$方式封锁了这个关系，该方式与方式$X$不相容，$T_4$必须等到$T_3$完成。
