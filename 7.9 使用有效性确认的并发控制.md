有效性确认是一种乐观的并发控制类型，允许事务不经封锁访问数据，而是在适当的时候检查事务是否以一种可串行化的方式运转。有效性确认和时间戳的主要区别是调度器维护关于活跃事务正在做什么，而不是为所有数据库元素保存读时间和写时间。事务开始为数据库元素写入值前的一刹那，它经过一个有效性确认阶段，这时用它已经读的和将写的元素集合与其他活跃事务的写集合作比较。如果存在事实上不可实现行为的风险，该事务就回滚。

### 基于有效性确认调度器的结构

当有效性确认被用作并发控制机制时，对每个事务$T$，调度器必须告知$T$所读和写的数据库元素集合，分别是读集合$RS(T)$和写集合$WS(T)$。事务分三个阶段来执行：

1. **读**：事务从数据库中读其读集合中的所有元素。事务还在局部地址空间中计算它将要写的所有值。
2. **有效性确认**：调度器通过比较该事务与其他事务的读写集合来确认该事务的有效性。如果有效性确认失败，则事务回滚，否则继续进入下一阶段。
3. **写**：事务往数据库中写入其集合中元素的值。

为了支持做出是否确认事务有效性的决定，调度器维护三个集合：

1. $START$，已经开始但尚未完成有效性确认的事务集合。对这个集合中的每个事务$T$，调度器维护$START(T)$，即事务$T$开始的时间。
2. $VAL$，已经确认有效性但尚未完成写的事务。对这个集合中的每个事务$T$，调度器维护$START(T)$和$VAL(T)$，即$T$确认的时间。$VAL(T)$也是假设的串行执行顺序中所设想的$T$的执行时间。
3. $FIN$，已完成写的事务。对这样的事务，调度器记录$START(T)$、VAL(T)和$FIN(T)$，即$T$完成的时间。原则上这个集合将一直增长。但是，如果对任意活跃事务$U$(即对任何在$START$或$VAL$中的$U$)，事务$T$满足$FIN(T) < START(U)$，这样的$T$我们不必记住。调度器因此可以周期性的清理$FIN$集合，以防止其一直增大。

### 有效性确认规则

###三种并发机制的比较