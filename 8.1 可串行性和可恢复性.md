### 脏数据问题

如果数据被未提交事务写入，那么该数据就是脏的。

### 级联回滚

如果事务可以获得脏数据，那么有时候我们需要执行**级联回滚**。当事务$T$中止时，我们必须确定哪些事务读取了由$T$写入的数据，中止这些事务，然后递归地中止读了被中止事务所写数据的所有事务。使用提交位的基于时间戳的调度器和基于有效性确认的调度器都能避免级联回滚。

### 可恢复的调度

如果调度中每一个事务都在它所读取的所有事务提交之后才提交，则该调度是**可恢复的**。

日志的提交记录到达磁盘的顺序必须和它们被写入的顺序一致。

### 避免级联回滚的调度

如果调度中的事务只读取已提交事务写入的数据，则称该调度为**避免级联回滚(avoid cascading rollback)**的调度(或$ACR$调度)。

每一个$ACR$调度都是可恢复的。

### 基于锁对回滚的管理

有一种简单常用的方法可以保证不产生级联回滚：

* **严格封锁**：直到事务提交或中止且提交或中止日志记录已被刷新到磁盘之后，事务才允许释放排他锁(或其他允许值发生改变的锁，如增量锁)。

遵守严格封锁规则的事务调度被称为**严格调度**。这种调度有两个重要的特性：

1. 每一个严格调度都是$ACR$调度。这是因为$T_2$无法读取$T_1$所写入的元素$X$的值，直到$T_1$释放所有的排他锁。
2. 每一个严格调度都是可串行化的。

![8-1-1](/Users/ace/z/keeplearning/images/8-1-1.jpg)

修复缓冲数据的难度依赖于数据库元素是块还是更小的东西。

#### 块的回滚

如果可封锁数据库元素是块，那么不需要日志即可回滚。

* 未提交事务所写的块被钉在主存里，不允许写入到磁盘。

如果使用的是多版本系统，那么必须假设未提交事务所写的块在内存里，我们只需从$A$的可用列表中去掉$T$所写入的值即可。

#### 小的数据库元素的回滚

当我们需要恢复中止事务修改过的一个小的数据库元素$A$的旧值时，有以下几种选择：

1. 从存储在磁盘的数据库中读取$A$原来的值，并对缓冲区内容做适当的修改。
2. 如果日志是undo或undo/redo日志，那么我们可以从日志中获取修改前的值。
3. 我们可以为每个事务所做的修改维护一个单独的主存日志，该日志仅在对应事务活跃时保留。旧值可以从这一日志获得。

### 成组提交

* 在事务完成且提交日志记录至少出现在缓冲区中以前不能释放锁。
* 日志记录按创建的顺序刷新。

### 逻辑日志

当数据库元素是块时至少有两个问题：

1. 所有日志方式都要求在日志中记录数据库元素的新值、旧值或二者都记录。如果块中变化较小，那么有大量冗余数据写入日志中。
2. 对于调度可恢复的要求，即只有提交后才能释放锁，会严重抑制并发性。

**逻辑日志**中只描述块中的变化。

1. 数据库元素的少量字节改变，例如更新一个定长字段。
2. 数据库元素的改变描述简单，易于恢复，但它产生的影响是改变了该数据库元素的大多数或全部字节。一种常见的情况是，记录一个变长字段改变，该记录的大部分甚至其他记录需要在块内滑动。
3. 变化影响到数据库元素的很多字节，且进一步的改变可能使这一变化变的不可撤销。这种情况是真正的逻辑日志，因为我们不能将undo/redo日志过程视为发生在数据库元素上，而应视为发生在数据库元素所代表的高层逻辑结构上。

###从逻辑日志中恢复

